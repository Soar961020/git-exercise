# 面试重点

#### 为什么用线程池？解释下线程池的参数？

1. 降低资源消耗；提高线程利用率，降低创建和销毁线程的消耗（核心原因）

2. 提高响应速度，任务来了，直接有线程可用可执行。而不是先创建线程，在执行

3. 提高线程的可管理性，线程是稀缺资源，使用线程池可以统一分配调优监控

   corePoolSize：代表核心线程数，也就是正常情况下创建工作的线程数

   maxinumPoolSize：代表的最大线程数，表示最大允许被创建的线程数

   workQueue：用来存放待执行的任务

   ThreadFactory：实际上是一个线程工厂，用来生产线程执行任务

   Handler：任务拒绝策略，有两种情况：一是使用shutdown等方法关闭线程池后，这时候即使线程池内部还有没执行完成的任务正在执行，由于线程池关闭，我们继续想线程池提交任务会遭到拒绝，另一种情况是当达到最大线程数，线程池已经没有能力继续处理新提交的任务时，这时也就会拒绝

#### 当任务数超过线程池核心线程数时，不进入队列，如何让它直接启用最大线程数

当我们提交到一个任务到线程池中的时候，它的工作原理可以分为四个步骤：

第一步：预热核心线程

第二步：把任务添加到阻塞队列

第三步：如果添加到阻塞队列失败，则创建非核心线程增加处理效率

第四步：如果非核心线程数达到了阙值，就会触发拒绝策略

如果我们希望任务不进入到这样一个阻塞队列，只需要影响第二个步骤的执行逻辑就好了，在Java线程池里面，它的构造方法有一个参数是可以去修改阻塞队列的这样一个类型，其中有一个阻塞队列叫做synchronousQueue，它是不能存储任何元素，它的特性时每生产一个任务，就必须指派一个消费者来处理这个任务，否则就会阻塞生产者，基于这个特性，我们只需要把线程池里面阻塞队列替换成synchronousQueue，就能避免任务直接进入到阻塞队列，而是直接启用最大线程数量去处理

#### 线程池是如何实现线程复用：

   使用生产者，消费者模式实现多线程的一个复用，通过中间容器解耦生成生产者和消费者处理任务的过程，生产者不断地生产任务保持到容器里面，消费者不断从容器里面去消费任务，在线程池里面，需要去保证工作线程一个重复使用，并且这些线程应该是有任务处理的时候执行，没有任务的时候就要等待，并且释放cpu的资源，所以它使用了阻塞队列来实现这样一个需求，提交任务到线程池里面的一个线程称为生产者线程，它不断地去往线程池里面传递任务，这些任务会保存到阻塞队列里面，然后线程池里面的工作线程不断地去从阻塞队列里面获取任务去执行，基于阻塞队列这样的一个特性，使得阻塞队列里面没有任何任务的时候，那么这些工作线程就会阻塞等待，直到又有新的任务进来的时候，那么这些工作线程会被再次唤醒，从而达到线程复用

面试官可能会问线程池中的阻塞队列的作用：普通队列只能保证作为一个有限长度的缓冲区，也就是说如果超过了缓冲长度，就无法保留当前的任务，阻塞队列可以通过阻塞来保留住当前想要继续入队的任务，阻塞队列自带阻塞和唤醒功能，不需要额外处理，无任务时，线程池利用阻塞队列的take方法挂起，从而为此核心线程的存活，不至于一直占用cpu资源

#### 线程池的线程回收：

可以从三个角度来回答：

- 线程池里面分为核心线程，它有两种创建方式来初始化：第一种是向线程池里面添加任务的时候，被动初始化，第二种是主动调用prestartAllCoreThreads方法去完成初始化
- 当线程池队列里面满了的情况下，为了增加线程池的任务处理能力，线程池会增加非核心线程，核心线程和非核心线程的数量是在构造线程池的时候设置的，也可以动态进行更改，由于非核心线程是为了解决在任务过多情况下临时增加的饿，所以当任务处理完成之后，工作线程处于空闲状态的时候，就需要进行回收，因为所有工作线程都是从阻塞队列里面去获取，要执行的任务，只需要在一定时间内阻塞队列没有任何可以处理的任务，那么这个线程就可以结束了，而这个功能是通过阻塞队列里面的poll方法来完成的，这个方法里面提供了一个超时时间和超时时间单位两个参数，当前线程在指定的时间没有从阻塞队列里面获取任务的时候，那么poll方法会返回null，从而去终止当前的线程，完成线程的回收
- 默认情况下，线程池只会回收非核心线程，如果我们希望核心线程也要能回收，那么我们可以设置allowCoreThreadTimeOut这样一个属性设置为true就可以了，一般情况下我们不会去回收核心线程，因为线程池本身就是实现线程的一个复用，而且这些核心线程在没有任务处理的时候，是出于阻塞状态的，并没有占用cpu资源，

#### 调用线程池的shutdown方法会发生什么？

shutdown()：它可以安全的关闭一个线程池

#### 线程池的创建方式有几种？有什么特点？



#### 简述线程池处理流程

![](C:\Users\是阿好啊\Desktop\DR]O8TY9HXRH~QAPX0{1IBY.png)





#### 线程的生命周期，有哪些状态

1.线程中通常有六种状态：

- 创建：新创建一个线程对象
- 就绪：线程对象创建后，其他线程调用该对象的start方法，该状态的线程位于可运行线程池中，等待获取cpu的使用权
- 运行：就绪状态的线程获取到了cpu，执行程序代码
- 阻塞：线程因为某种原因放弃对cpu的使用权，暂时停止运行，直到线程进入就绪状态，才有机会进入到运行状态
- 死亡：线程执行完了或者异常退出了run方法，该线程结束生命周期

2，阻塞又分为三种：

- 等待阻塞：运行的线程执行wait方法，该线程会释放占有的资源，jvm就会把该线程放入等待池中，进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify或者notifyAll方法才能被唤醒，wait是Object里面的方法
- 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，那么jvm会把该线程放入锁池中
- 其他阻塞：运行的线程执行sleep方法时，jvm会把该线程设置为阻塞状态，当sleep超时，线程重新转入就绪状态，sleep时Tread类的方法

#### 线程状态blocked和waiting有什么区别

blocked和waiting都是属于线程阻塞等待状态

blocked状态是指线程在等待监视器锁的时候的一个阻塞状态，也就是说在多个线程去竞争Synchronized同步锁的时候，没有竞争到锁的线程会被阻塞等待，而这个时候线程状态就叫做blocked，在线程整个生命周期里面，只有Synchronized同步锁等待才会存在这个状态

waiting状态表示线程的等待状态，在这种状态里面，线程需要等待某一个线程的特定操作，才会被唤醒，我们可以使用Object.wait() ，Object.join()等方法使得线程进入到一个 waiting状态，在这个状态下，我们必须等待特定的方法来唤醒，比如  Object.notify()可以去唤醒Object.wait()方法阻塞的线程

在我看来blocked和waiting这两个状态的最大区别是：

- blocked是锁竞争失败后被动触发的状态，waiting是人为的主动触发的状态
- 处于blocked状态下的线程时它的唤醒时自动触发，也就是说获得锁的线程释放之后，会触发这一个唤醒动作，而处于waiting状态下的线程，必须要通过特定方法来主动唤醒

#### 如果一个线程两次调用start()会出现什么问题

在Java里面一个线程只能调用一次start()方法，IllegalThreadStateException，这是一种运行时异常，多次调用start被认为是编程错误。

一个线程本身具有一个生命周期的饿，线程的生命周期包括6种状态，当我们第一次调用start()方法，线程的状态可能处于终止状态或者说非new状态下的一个其他状态，再次调用start()方法的时候，相当于让这个正在运行的线程重新运行一遍，不管是从线程安全性角度来看还是从线程本身的执行逻辑来看，它都是不合理的，因此为了避免这一问题，在线程运行的时候会先会判断当前线程的一个运行状态，

#### 谈谈你对线程安全的理解

当多个线程访问某个对象或者方法的时候，在程序中不做任何的同步干预，调用这个对象或者方法都能获得正确的结果，何为正确的结果：多个线程访问同一个对象时和单线程执行结果是一样的

#### 多线程怎样实现线程安全？

1.使用同步关键字synchronized或者Lock使线程互斥同步

2.使用ThreadLocal实现多个线程之间的数据隔离

#### local和synchronized的区别

相同点：都是Java中去解决线程安全问题的一个工具

不同点：local

#### ThreadLocal及实现原理和使用场景

ThreadLocal：是线程隔离机制，提供在多线程环境下，对共享变量访问的一个安全性

当多线程访问共享变量时，一般情况是加锁，保证同一时刻只有一个线程能对共享变量进行更新，并且基于锁监视器的一个规则，保证数据修改之后对其他线程是可见的，加锁会带来性能上的下降，所以ThreadLocal使用一种空间换时间的设计思想，它相当于让每个线程开辟了一块内存空间，来储存共享变量的一个副本，每个线程只对自己的变量副本做更新操作，即解决了线程安全又避免多线程竞争锁的问题，

具体实现原理是在Thread类里面有一个ThreadLocalMap类型的成员变量：它是专门来存储当前线程的共享变量的副本，后续对共享变量操作都是从ThreadLocal里面更新操作，不会影响全局变量的值，从而实现数据隔离，ThreadLocalMap中key指向的是弱引用ThreadLocal实例，value为共享变量的副本

使用场景：

- 在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束
- 线程间的数据隔离
- 进行事务操作，可以用于存储线程事务信息
- 数据库连接，Session会话管理

#### ThreadLocal内存泄漏原因，如何避免

什么是内存泄漏：不再会被使用的对象或者变量占用的内存不能被回收，就会内存泄漏

首先要了解Java中的强弱引用

强引用：使用最普遍引用时new关键字，还有通过反射，一个对象具有强引用，不会被垃圾回收器回收，当内存空间不足，Java虚拟机宁愿抛出错误，使程序异常终止，也不回收这种对象

如果想要取消强应用和某个对象之间的关联，可以显式的将引用赋值为null，这样的话jvm到合适的时间就会回收该对象

弱引用：jvm进行垃圾回收时，无论内存空间是否充足，都会回收被弱引用关联的对象

#### 死锁的发生原因和怎么避免？

死锁：两个或者两个以上的线程在执行过程中，去竞争同一个共享资源，导致互相等待的一个现象，在没有外部干预的情况下，线程会一直处于阻塞状态，无法往下执行，要想死锁要同时满足四个条件：

1.互斥条件：共享资源x和y只能被一个线程占有

2.请求和保持条件：线程t1已经获得共享资源x，在等待共享资源y的时候不释放共享资源x

3.不可抢占条件：其他线程不能强行去抢占t1已经占有的资源

4.循环等待条件：线程t1等待线程t2占有了资源，线程t2等待线程t1占有了资源，形成了一个循环等待

线程在产生死锁之后，只能通过外部干预来解决，所以我们在写代码的时候就应该可以规避死锁的一个问题也就是避免同时满足这四个条件，那么在这四个条件当中互斥条件时锁本身的一个特征，无法被破坏，其他三个条件都可以被破坏，对于请求和保持条件，我们可以在第一次执行的时候一次性申请完所有的共享资源，对于不可抢占条件，占用部分资源的线程再进一步去申请其他资源的时候，如果申请不到就主动释放它占有的资源，对于循环等待条件，可以按照顺序申请锁资源，相当于给资源一个编号，按照顺序申请锁资源避免循环等待的问题

#### wait，sleep，join，yield的区别

首先要了解锁池：

 所有需要竞争同步锁的线程都会被放在锁池中，比如当前对象的同步锁已经被其中一个线程得到，则其他线程需要在这个锁池进行等待，当前面的线程池中的线程去竞争同步锁，当某个线程得到后会进入就绪队列等待cpu资源分配

等待池：当我们调用wait方法后，线程会被放入等待池中，等待池中的线程不会去竞争同步锁，只有调用notify或者notifyAll后等待池中的线程才会开始去竞争同步锁

notify：是随机从等待池选出一个线程放到锁池

notifyAll：是将等待池的所有线程放到锁池当中

sleep和wait区别

- 1.sleep是Thread类的静态本地方法，wait是object类的本地方法
- 2.sleep方法不会释放锁的资源，会释放cpu资源，wait会释放锁资源和cpu资源
- 3.sleep方法不依赖同步器synchronized，wait需要依赖synchronized关键字
- 4.sleep一般用于当前线程休眠，wait多用于多线程之间的通信

yield方法：执行后线程直接进入就绪状态，马上释放cpu的执行权，但是依然保留对cpu的执行资格，所以有可能cpu下次进行线程调度还会让这个线程获取到执行权继续执行

join方法：执行后线程进入到阻塞状态，例如在线程B中调用线程A的join() 那么线程B会进入到阻塞队列，直到线程A结束或者中断

#### 并发，并行，串行的区别

串行：在时间上不可能发生重叠，前一个任务没搞定，下一个任务只能等着

并行：在时间上是重叠的，两个任务在同一时间互不干扰的同时执行

并发：允许两个任务彼此干扰，统一时间点，只有一个任务运行，交替执行

#### 

















​    